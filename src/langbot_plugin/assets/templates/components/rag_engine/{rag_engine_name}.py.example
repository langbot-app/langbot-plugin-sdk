# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

from langbot_plugin.api.definition.components.rag_engine.engine import (
    RAGEngine,
    RAGEngineCapability,
)
from langbot_plugin.api.entities.builtin.rag.context import (
    RetrievalContext,
    RetrievalResponse,
    RetrievalResultEntry,
)
from langbot_plugin.api.entities.builtin.rag.models import (
    IngestionContext,
    IngestionResult,
)
from langbot_plugin.api.entities.builtin.rag.enums import DocumentStatus
from langbot_plugin.api.entities.builtin.provider.message import ContentElement


class {{ rag_engine_attr }}(RAGEngine):
    """RAG Engine component for knowledge base operations.

    This component handles document ingestion, deletion, and retrieval
    for a knowledge base.
    """

    @classmethod
    def get_capabilities(cls) -> list[str]:
        """Declare engine capabilities.

        Available capabilities:
        - RAGEngineCapability.DOC_INGESTION: Supports document upload
        - RAGEngineCapability.CHUNKING_CONFIG: Supports custom chunking
        - RAGEngineCapability.RERANK: Supports result reranking
        - RAGEngineCapability.HYBRID_SEARCH: Supports hybrid search
        """
        return [RAGEngineCapability.DOC_INGESTION]

    async def on_knowledge_base_create(self, kb_id: str, config: dict) -> None:
        """Called when a knowledge base is created."""
        pass

    async def on_knowledge_base_delete(self, kb_id: str) -> None:
        """Called when a knowledge base is deleted."""
        pass

    async def ingest(self, context: IngestionContext) -> IngestionResult:
        """Ingest a document into the knowledge base.

        Args:
            context: Contains file info, kb_id, and settings.

        Returns:
            IngestionResult with status and metadata.
        """
        # 1. Get file content
        file_content = await self.plugin.get_rag_file_stream(
            context.file_object.storage_path
        )

        # 2. Parse and chunk the content
        chunks = []  # TODO: Implement chunking logic

        # 3. Embed chunks
        # embeddings = await self.plugin.rag_embed_documents(
        #     context.knowledge_base_id, [chunk.text for chunk in chunks]
        # )

        # 4. Store in vector database
        # await self.plugin.vector_upsert(
        #     collection_id=context.get_collection_id(),
        #     vectors=embeddings,
        #     ids=[chunk.chunk_id for chunk in chunks],
        #     metadata=[chunk.metadata for chunk in chunks],
        # )

        return IngestionResult(
            document_id=context.file_object.metadata.document_id,
            status=DocumentStatus.COMPLETED,
            chunks_created=len(chunks),
        )

    async def delete_document(self, kb_id: str, document_id: str) -> bool:
        """Delete a document from the knowledge base.

        Args:
            kb_id: Knowledge base identifier.
            document_id: Document identifier to delete.

        Returns:
            True if deletion was successful.
        """
        # TODO: Delete vectors associated with the document
        # await self.plugin.vector_delete(
        #     collection_id=kb_id,
        #     filters={"document_id": document_id},
        # )
        return True

    async def retrieve(self, context: RetrievalContext) -> RetrievalResponse:
        """Retrieve relevant content from the knowledge base.

        Args:
            context: Contains query, kb_id, and retrieval_settings.

        Returns:
            RetrievalResponse with results.
        """
        # 1. Embed query
        # query_embedding = await self.plugin.rag_embed_query(
        #     context.knowledge_base_id, context.query
        # )

        # 2. Search vectors
        # top_k = context.retrieval_settings.get('top_k', 5)
        # results = await self.plugin.vector_search(
        #     collection_id=context.get_collection_id(),
        #     query_vector=query_embedding,
        #     top_k=top_k,
        # )

        # 3. Build response
        entries = []
        # for result in results:
        #     entries.append(RetrievalResultEntry(
        #         id=result["id"],
        #         content=[ContentElement(type="text", text=result["text"])],
        #         metadata=result.get("metadata", {}),
        #         distance=result.get("distance", 0.0),
        #         score=result.get("score", 0.0),
        #     ))

        return RetrievalResponse(
            results=entries,
            total_found=len(entries),
        )
